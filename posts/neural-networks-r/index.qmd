---
title: Neural Network from Scratch in Base R
author: "Lukman Aliyu Jibril"
date: "2023-09-26"
categories : [deep learning, r, neural networks]
draft: true
---

```{r}
# Activation function
sigmoid <- function(x) {
  1 / (1 + exp(-x))
}

# Derivative of activation function
sigmoid_prime <- function(x) {
  x * (1 - x)
}

# Hyperparameters
input_size <- 4  # Input layer size (4 features for iris dataset)
hidden_size <- 5  # Hidden layer size
output_size <- 1  # Output layer size

# Initialize weights and biases
set.seed(123)  # For reproducibility
weights_input_hidden <- matrix(runif(input_size * hidden_size, -1, 1), nrow=input_size)
weights_hidden_output <- matrix(runif(hidden_size * output_size, -1, 1), nrow=hidden_size)

biases_hidden <- matrix(runif(hidden_size, -1, 1), nrow=hidden_size, ncol=1)
biases_output <- matrix(runif(output_size, -1, 1), nrow=output_size, ncol=1)

```

## Forward Propagation

```{r}

forward_propagation <- function(input_data) {
  hidden_layer_input <- input_data %*% weights_input_hidden + t(biases_hidden)
  hidden_layer_output <- sigmoid(hidden_layer_input)
  
  output_layer_input <- hidden_layer_output %*% weights_hidden_output + t(biases_output)
  predicted_output <- sigmoid(output_layer_input)
  
  list(hidden_layer_output=hidden_layer_output, predicted_output=predicted_output)
}

```


## Backward Propagation

```{r}

backward_propagation <- function(input_data, output_data, hidden_layer_output, predicted_output, learning_rate = 0.01) {
  output_error <- output_data - predicted_output
  output_delta <- output_error * sigmoid_prime(predicted_output)
  
  hidden_layer_error <- output_delta %*% t(weights_hidden_output)
  hidden_layer_delta <- hidden_layer_error * sigmoid_prime(hidden_layer_output)
  
  # Update the weights and biases
  weights_hidden_output <- weights_hidden_output + t(hidden_layer_output) %*% output_delta * learning_rate
  biases_output <- biases_output + colSums(output_delta) * learning_rate
  
  weights_input_hidden <- weights_input_hidden + t(input_data) %*% hidden_layer_delta * learning_rate
  biases_hidden <- biases_hidden + colSums(hidden_layer_delta) * learning_rate
}

```

## Training

```{r}
data(iris)

set.seed(123)
indexes <- sample(1:nrow(iris), 30)
test_input <- as.matrix(iris[indexes, 1:4])
test_output <- as.matrix(ifelse(iris[indexes, "Species"] == "setosa", 1, 0))

train_input <- as.matrix(iris[-indexes, 1:4])
train_output <- as.matrix(ifelse(iris[-indexes, "Species"] == "setosa", 1, 0))


epochs <- 1000

for (epoch in 1:epochs) {
  forward_results <- forward_propagation(train_input)
  backward_propagation(train_input, train_output, forward_results$hidden_layer_output, forward_results$predicted_output)
}

```


## Testing the network

```{r}
test_results <- forward_propagation(test_input)
predicted_values <- test_results$predicted_output
# Binarizing the output (useful for classification tasks)
predicted_class <- ifelse(predicted_values > 0.5, 1, 0)

# Calculate accuracy
accuracy <- sum(predicted_class == test_output) / length(test_output)
print(paste("Accuracy:", accuracy * 100, "%"))
```


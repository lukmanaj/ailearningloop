{
  "hash": "2803447ef8fe00e42ef4606ee3e131a3",
  "result": {
    "markdown": "---\ntitle: \"Exploring Pandas: A Powerful Pythonic Analytic Tool\"\nauthor: \"Lukman Aliyu Jibril\"\ndate: \"2023-03-14\"\ncategories: [pandas,python,data analysis]\nimage: \"pandas.jpg\"\n---\n\nData analysis is a much sought after skill for data science. In my search for efficient tools for analyzing data, after outgrowing spreadsheets, I came across other tools like R's tidyverse but discovering pandas was a game changer. \n\npandas is hardly used alone and mostly use alongside numerical computing tools like NumPy and Scipy and visualization tools like matplotlib or seaborn. pandas is closely associated with NumPy as it adopts certain aspects of NumPy's array-based computing like array-based functions and vectorization (basically eliminating for loops in Python). \n\nComparing NumPy and pandas, I'll say the biggest difference is that while pandas work with tabular data in rows and columns (which can be heterogeneous), NumPy is most suited for homogeneous numerical array data that is usually typed.\n\nPandas is a super popular library for fast and convenient data analysis built on top of the Python programming language, that provides two data structures for data manipulation:\n1. Series\n2. DataFrames\n\nA series is a one dimensional array of indexed data that consists of an array of actual data and an associated array of indices or labels. \n\nA DataFrame on the other hand is a two dimensional data structure. The data is usually tabular and arranged in rows and columns. A DataFrame can be created from lists, dictionaries or lists of dictionaries. It can also be created by loading data from storage like csv files, SQL database, excel files etc. \n\nThe index (of pandas Series or DataFrame) is used to access individual data values. A column of a dataframe can also be accessed as a Series. A pandas series is for all intents and purposes a 1-D dataframe.\n\nTo illustrate some of the concepts already mentioned, it is necessary to import pandas. In this article, it is assumed that the individual already has Python and pandas installed.\nImporting pandas is usually done usng the syntax below:\n\n```py\nimport pandas as pd\n\n```\n\nSince pandas is hardly used alone, the following is a more realistic import:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n```\n:::\n\n\nIn addition, since the Series and DataFrame functions will most likely be frequently used, they can be imported as below:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom pandas import Series, DataFrame\n```\n:::\n\n\n### Creating pandas series and DataFrames\n\nHere I will briefly provide the syntax for creating pandas series and DataFrame objects. \nTo create a pandas series object, the following can suffice:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nobj = Series([4,7,-5,3])\nobj\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n0    4\n1    7\n2   -5\n3    3\ndtype: int64\n```\n:::\n:::\n\n\nTo create a DataFrame from a dictionary:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n#Define the dictionary 'x'\n\nx = {'Name': ['Lukman','Aminu', 'Amina', 'Fatima'], 'ID': [1, 2, 3, 4], 'Department': ['Architect Group', 'Software Group', 'Design Team', 'Infrastructure'], \n      'Salary':[100000, 80000, 50000, 60000]}\n\n#casting the dictionary to a DataFrame\ndf = pd.DataFrame(x)\n\n#display the result df\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>ID</th>\n      <th>Department</th>\n      <th>Salary</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Lukman</td>\n      <td>1</td>\n      <td>Architect Group</td>\n      <td>100000</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Aminu</td>\n      <td>2</td>\n      <td>Software Group</td>\n      <td>80000</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Amina</td>\n      <td>3</td>\n      <td>Design Team</td>\n      <td>50000</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Fatima</td>\n      <td>4</td>\n      <td>Infrastructure</td>\n      <td>60000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThere's a direct correspondence between the table and the dictionary. The keys correspond to the column labels and the values or lists corresponding to the rows.\nDataFrames can also be created from lists, lists of lists or loaded from storage:\n\n```py\ndf = pd.read_csv('example.csv')\n```\nThe advantage of loading from storage is that there wont be a need to type in the data and it supports working on large datasets. \n\nI will concentrate more on manipulating DataFrames. \n\n### Column selection in pandas dataframes\n\nColumns can be selected using two different notations:\n1. df['columnname.]: returns a series: or df[['columnname']]: returns a DataFrame\n2. df.columnname \nThe second notation only works if the columnname is a valid Python variable. \n\nMultiple columns can be accessed by passing the list of columns as follows:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndf[['Name','ID']]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>ID</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>Lukman</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Aminu</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>Amina</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Fatima</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Using loc and iloc functions for selecting ranges in a DataFrame\n\nloc() is a label-based data selecting method which means that we have to pass the name of the row or column that we want to select. This method includes the last element of the range passed in it.\n\nThe syntax can be simplified below:\n\n```py\nloc[row_label, column_label]\n```\n\niloc() is an indexed-based selecting method which means that we have to pass integer index in the method to select a specific row/column. This method does not include the last element of the range passed in it.\n\nThe syntax can be simplified below:\n\n```py\niloc[row_index, column_index]\n```\n### Performing arithmetic on pandas DataFrames\n\npandas allows for easy arithmetic on DataFrames with different labels by providing the union of the dataframes. \nFor example:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndf1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list(\"bcd\"),\n                      index=[\"Kaduna\", \"Kano\", \"Katsina\"])\n\ndf2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list(\"bde\"),\n                      index=[\"Sokoto\", \"Kano\", \"Kaduna\", \"Kebbi\"])\nprint(df1,'\\n')\nprint(df2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           b    c    d\nKaduna   0.0  1.0  2.0\nKano     3.0  4.0  5.0\nKatsina  6.0  7.0  8.0 \n\n          b     d     e\nSokoto  0.0   1.0   2.0\nKano    3.0   4.0   5.0\nKaduna  6.0   7.0   8.0\nKebbi   9.0  10.0  11.0\n```\n:::\n:::\n\n\nThe beauty of pandas is that it aligns on both the rows and columns and provide the sum for where the rows or columns appear in both DataFrames and returns NA for those that are not in both as shown below:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndf1 + df2\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>b</th>\n      <th>c</th>\n      <th>d</th>\n      <th>e</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Kaduna</th>\n      <td>6.0</td>\n      <td>NaN</td>\n      <td>9.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>Kano</th>\n      <td>6.0</td>\n      <td>NaN</td>\n      <td>9.0</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>Katsina</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>Kebbi</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>Sokoto</th>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n      <td>NaN</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn addition, pandas has some flexible arithmetic methods for calculations in DataFrames and series. These include:\n\n1. add, radd\n2. sub, rsub\n3. div, rdiv etc\n\nOperations between DataFrames and series are also supported, just like broadcasting in NumPy.\n\n### Computing descriptive statistics\n\npandas objects have built-in methods for computing descriptive statistics on DataFrames and series. For instance:\n-  Calling DataFrameâ€™s sum method returns a Series containing column sums, passing axis=\"columns\" or axis=1 sums across the columns instead:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndf.sum()\n\ndf.sum(axis=1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_5818/680404804.py:3: FutureWarning:\n\nDropping of nuisance columns in DataFrame reductions (with 'numeric_only=None') is deprecated; in a future version this will raise TypeError.  Select only valid columns before calling the reduction.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n0    100001\n1     80002\n2     50003\n3     60004\ndtype: int64\n```\n:::\n:::\n\n\n- Same can be done to get the column means or row means (axis = 1):\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndf.mean()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_5818/3698961737.py:1: FutureWarning:\n\nThe default value of numeric_only in DataFrame.mean is deprecated. In a future version, it will default to False. In addition, specifying 'numeric_only=None' is deprecated. Select only valid columns or specify the value of numeric_only to silence this warning.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\nID            2.5\nSalary    72500.0\ndtype: float64\n```\n:::\n:::\n\n\n- Describe method produces multiple summary statistics all at once for all the columns\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndf.describe()\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>ID</th>\n      <th>Salary</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>count</th>\n      <td>4.000000</td>\n      <td>4.000000</td>\n    </tr>\n    <tr>\n      <th>mean</th>\n      <td>2.500000</td>\n      <td>72500.000000</td>\n    </tr>\n    <tr>\n      <th>std</th>\n      <td>1.290994</td>\n      <td>22173.557826</td>\n    </tr>\n    <tr>\n      <th>min</th>\n      <td>1.000000</td>\n      <td>50000.000000</td>\n    </tr>\n    <tr>\n      <th>25%</th>\n      <td>1.750000</td>\n      <td>57500.000000</td>\n    </tr>\n    <tr>\n      <th>50%</th>\n      <td>2.500000</td>\n      <td>70000.000000</td>\n    </tr>\n    <tr>\n      <th>75%</th>\n      <td>3.250000</td>\n      <td>85000.000000</td>\n    </tr>\n    <tr>\n      <th>max</th>\n      <td>4.000000</td>\n      <td>100000.000000</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThere are various other methods for obtaining specific summary statistics in a DataFrame. The aim here is just to provide a taste of the possibilities, as with my NumPy article.\n\nIn conclusion, pandas is a powerful library with useful tools for data analysis and in this article, I attempted to provide a glimpse of what can be achieved with pandas. The pandas documentation is a useful resource alongside an individual's inquisitiveness and willingness to explore different datasets using pandas. In addition, I found Python for Data Analysis by Wes McKinney quite useful as it gave an intuition into data analysis with Python. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}
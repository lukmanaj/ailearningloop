{
  "hash": "7929c341d87f8987159d5b70c6e2db87",
  "result": {
    "markdown": "---\ntitle: \"Introduction to Symbolic Computation with SymPy\"\nauthor: \"Lukman Aliyu Jibril\"\ndate: \"2023-08-15\"\ncategories: [python,sympy,mathematics,symbolic computing]\n---\n\nSymbolic computation is a powerful approach in mathematics and computer science that deals with manipulating expressions and equations in their symbolic form. Unlike numerical computation, where values are approximated and manipulated, symbolic computation focuses on maintaining expressions with variables, allowing for precise mathematical manipulation. In this article, we will delve into symbolic differentiation using the popular SymPy library in Python. \n\n## Basic Numeric Approximation\n\nWhen approximating the square root of 18, you might typically use the math module in Python:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport math\n\nmath.sqrt(18)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n4.242640687119285\n```\n:::\n:::\n\n\nHowever, this result is an approximation. To work symbolically, we turn to SymPy:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport sympy\n\nsqrt_expr = sympy.sqrt(18)\nsqrt_expr\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n$\\displaystyle 3 \\sqrt{2}$\n:::\n:::\n\n\nSymPy provides an exact symbolic representation of the square root of 18. You can also evaluate this expression numerically to a specified number of decimal places:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\napprox_val = sympy.N(sqrt_expr, 8)\napprox_val\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n$\\displaystyle 4.2426407$\n:::\n:::\n\n\n## Symbolic Manipulation\n\nIn SymPy, expressions are built using symbols. Here's an example of creating a symbolic expression corresponding to the mathematical expression $2x^{2}-xy$ :\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nx, y = sympy.symbols('x y')\nexpr = 2 * x**2 - x * y\nexpr\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n$\\displaystyle 2 x^{2} - x y$\n:::\n:::\n\n\nWith symbolic expressions, you can perform various manipulations, such as addition, subtraction, and multiplication:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nexpr_manip = x * (expr + x * y + x**3)\nexpr_manip\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n$\\displaystyle x \\left(x^{3} + 2 x^{2}\\right)$\n:::\n:::\n\n\nExpressions can also be expanded and factored using the expand and factor functions, respectively.\n\n### Substitution and Evaluation\n\nYou can substitute specific values into expressions using the evalf method:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nval = expr.evalf(subs={x: -1, y: 2})\nval\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n$\\displaystyle 4.0$\n:::\n:::\n\n\nThis allows you to evaluate expressions as functions:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nf_symb = x ** 2\nf_val = f_symb.evalf(subs={x: 3})\nf_val \n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n$\\displaystyle 9.0$\n:::\n:::\n\n\n## Numeric Operations on Symbolic Functions\n\nTo evaluate a symbolic function for each element of an array, you need to make it NumPy-compatible:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport numpy as np\nfrom sympy.utilities.lambdify import lambdify\n\nx_array = np.array([1, 2, 3])\nf_symb_numpy = lambdify(x, f_symb, 'numpy')\n\nresult_array = f_symb_numpy(x_array)\nresult_array\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([1, 4, 9])\n```\n:::\n:::\n\n\n## Symbolic Differentiation with SymPy\n\nSymPy excels in symbolic differentiation. Finding derivatives is straightforward:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndiff_result = sympy.diff(x**3, x)\ndiff_result\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n$\\displaystyle 3 x^{2}$\n:::\n:::\n\n\nSymPy handles standard functions and applies necessary rules for differentiation:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ndfdx_composed = sympy.diff(sympy.exp(-2*x) + 3*sympy.sin(3*x), x)\nprint(dfdx_composed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9*cos(3*x) - 2*exp(-2*x)\n```\n:::\n:::\n\n\nYou can even differentiate the symbolic expression from before and make it NumPy-friendly:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ndfdx_symb = sympy.diff(expr, x)\ndfdx_symb_numpy = lambdify(x, dfdx_symb, 'numpy')\n\ndiff_result_array = dfdx_symb_numpy(x_array)\ndiff_result_array\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([4 - y, 8 - y, 12 - y], dtype=object)\n```\n:::\n:::\n\n\n## Limitations of Symbolic Differentiation\n\nDespite its advantages, symbolic differentiation has limitations. Complex expressions might lead to inefficient or unevaluable results. For example, consider differentiating $|x|$ :\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndfdx_abs = sympy.diff(abs(x), x)\nprint(dfdx_abs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(re(x)*Derivative(re(x), x) + im(x)*Derivative(im(x), x))*sign(x)/x\n```\n:::\n:::\n\n\nEvaluating we get:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\neval_result = dfdx_abs.evalf(subs={x: -2})\neval_result\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n$\\displaystyle - \\left. \\frac{d}{d x} \\operatorname{re}{\\left(x\\right)} \\right|_{\\substack{ x=-2 }}$\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ntry:\n    dfdx_abs_numpy = lambdify(x, dfdx_abs, 'numpy')\n    dfdx_abs_numpy(np.array([1, -2, 0]))\nexcept NameError as err:\n    print(err)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nname 'Derivative' is not defined\n```\n:::\n:::\n\n\n## Numerical Differentiation\n\nNumerical differentiation approximates derivatives using nearby points and is available through libraries like NumPy. This approach focuses on function evaluation rather than symbolic expressions:\n\n```python\ndelta_x = 0.01\nnumerical_derivative = (f(x + delta_x) - f(x)) / delta_x\n```\n\n### Numerical Differentiation with NumPy\n\nNumPy provides the `np.gradient` function for numerical differentiation:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nimport numpy as np\n\nx_vals = np.linspace(0, 10, 100)\ny_vals = np.sin(x_vals)\n\nderivatives = np.gradient(y_vals, x_vals)\nprint(derivatives)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0.99830036  0.99321184  0.97799815  0.95281439  0.91791729  0.8736626\n  0.82050147  0.75897585  0.68971295  0.61341886  0.53087135  0.44291195\n  0.35043734  0.25439024  0.15574979  0.05552157 -0.04527265 -0.14560535\n -0.2444537  -0.34080999 -0.43369194 -0.52215268 -0.6052904  -0.68225756\n -0.75226954 -0.81461261 -0.86865122 -0.91383447 -0.94970177 -0.97588745\n -0.99212457 -0.99824762 -0.99419416 -0.98000551 -0.95582633 -0.92190311\n -0.87858166 -0.82630363 -0.76560196 -0.69709546 -0.62148251 -0.53953394\n -0.45208516 -0.36002765 -0.2642999  -0.16587777 -0.06576463  0.03501895\n  0.13544553  0.23449132  0.33114663  0.4244261   0.51337882  0.59709797\n  0.67473008  0.74548374  0.80863767  0.86354805  0.9096551   0.94648879\n  0.97367362  0.99093247  0.99808939  0.99507142  0.98190932  0.95873728\n  0.92579151  0.88340789  0.83201848  0.77214717  0.7044043   0.62948048\n  0.54813951  0.46121059  0.36957993  0.27418163  0.17598823  0.07600073\n -0.02476154 -0.12527139 -0.22450417 -0.32144828 -0.41511542 -0.50455072\n -0.58884245 -0.6671313  -0.73861917 -0.80257728 -0.85835363 -0.9053796\n -0.9431758  -0.97135691 -0.98963566 -0.9978257  -0.99584353 -0.98370937\n -0.96154691 -0.92958209 -0.88814077 -0.86509787]\n```\n:::\n:::\n\n\n## Conclusion\n\nSymbolic computation with SymPy offers a versatile way to manipulate mathematical expressions and perform differentiation symbolically. While powerful, it has limitations in handling complex expressions and might lead to inefficient computations. Numerical differentiation, on the other hand, provides an alternative for cases where symbolic computation might fall short. By combining these techniques, you can effectively explore and analyze mathematical functions in Python.\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}
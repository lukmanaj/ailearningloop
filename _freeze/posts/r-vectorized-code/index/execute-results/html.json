{
  "hash": "d704884e712256d62abbfc3ee354c307",
  "result": {
    "markdown": "---\ntitle: \"Mastering Vectorized Code: Boosting Efficiency in R\"\nauthor: \"Lukman Aliyu Jibril\"\ndate: \"2023-07-29\"\ncategories: [r programming, vectorization]\n---\n\n\nIn the world of programming, efficiency is a golden goal. One clever technique to achieve this is using vectorized code. Vectorized code might sound complex, but it's like a superhero power for your programs. Imagine if you could do tasks on a bunch of numbers all at once, without going through them one by one. That's the magic of vectorized code! In this article, we'll explore what vectorized code is, why it's awesome, and how it makes your R programming faster and smoother.\n\nSo, what's the secret sauce of vectorized code? It's like having a bunch of superpowers rolled into one. Vectorized code is all about doing things at once – it's like multitasking for your computer. Instead of looping over each number separately, you perform operations on whole groups of numbers in one go. This can make your R code run way faster and feel snappier.\n\nLet's imagine we're dealing with a bunch of numbers and we want to transform them. We'll use two functions to do this, each with its own style. One function will be the superhero – it'll use vectorized code. The other function will be the regular person – it won't use vectorized code, and it'll take longer to do the same job.\n\n### The Regular Approach: No Superpowers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabs_loop <- function(vec){\n  for (i in 1:length(vec)) {\n    if (vec[i] < 0) {\n      vec[i] <- -vec[i]\n    }\n  }\n  vec\n}\n```\n:::\n\n\n\n### Embracing Vectorization: The Superhero\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabs_sets <- function(vec){\n  negs <- vec < 0\n  vec[negs] <- vec[negs] * -1\n  vec\n}\n```\n:::\n\n\nNow, let's put these functions to the test. We've got a bunch of numbers in a variable called long.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong <- rep(c(-1, 1), 5000000)\n```\n:::\n\n\nIt's time for the showdown! We'll measure how fast each function works.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Non vectorized\nprint(\"Nonvectorized\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Nonvectorized\"\n```\n:::\n\n```{.r .cell-code}\nsystem.time(abs_loop(long))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.744   0.059   0.803 \n```\n:::\n\n```{.r .cell-code}\n# Vectorized\n\nprint(\"Vectorized\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Vectorized\"\n```\n:::\n\n```{.r .cell-code}\nsystem.time(abs_sets(long))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.198   0.091   0.289 \n```\n:::\n:::\n\n\nThe result is in – the vectorized abs_sets() function wins the race by being around three times faster! This difference gets even bigger as we deal with larger batches of numbers. Think about the time you can save when working with big sets of data. Your code becomes a speedster, and your computer can focus on more exciting things.\n\nIn the world of R programming, vectorization is like a secret ingredient that gives you superpowers. Since R loves working with vectors, most R functions are already set up for vectorized operations. This means using vectorization can level up your programming skills and save you time and effort.\n\nTo wrap it up, diving into vectorized code is like discovering a hidden treasure. Its power to tackle tasks in one swift move, without tediously looping through each item, is a game-changer. As R programming evolves, vectorization remains a steadfast companion – a guiding star in the quest for efficient and elegant coding. So, why wait? Unleash the power of vectorized code and watch your R programming prowess soar!\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
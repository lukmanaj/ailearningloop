{
  "hash": "dcbfa043a1981b66410451015635b8eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Object Oriented Programming: Python vs R\"\nauthor: \"Lukman Aliyu Jibril\"\ndate: \"2024-03-06\"\ncategories: [oop,python,rprogramming]\n---\n\n\n\n## Introduction\n\nObject-Oriented Programming (OOP) is a programming paradigm that uses \"objects\" to design applications and computer programs. It utilizes several techniques from previously established paradigms, including modularity, polymorphism, and encapsulation. Today, we'll explore how OOP concepts manifest in two popular programming languages: Python and R, particularly focusing on inheritance, using the context of a microwave oven as an example.\n\n\n## OOP in Python\n\nIn Python, OOP is central to the language. This can be seen in the way classes are defined and used. Python supports inheritance, allowing new classes to inherit attributes and methods from existing classes. This feature facilitates code reusability and the hierarchical organization of classes. For example, if you were modeling microwave ovens, you could start with a basic microwave class and then create a subclass for a fancier microwave with additional features:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass MicrowaveOven:\n    def __init__(self, power_rating):\n        self.power_rating = power_rating\n\n    def cook(self, time_seconds):\n        print(\"Your food is cooked!\")\n\nclass FancyMicrowaveOven(MicrowaveOven):\n    def cook_baked_potato(self):\n        self.cook(5)\n        print(\"Enjoy your baked potato!\")\n\na_fancy_microwave = FancyMicrowaveOven(5)\na_fancy_microwave.cook_baked_potato()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nYour food is cooked!\nEnjoy your baked potato!\n```\n\n\n:::\n:::\n\n\n\nIn this Python example, FancyMicrowaveOven inherits from MicrowaveOven, meaning it can use the cook method defined in the parent class and add its methods like cook_baked_potato.\n\n## OOP in R \n\nIn contrast, R, traditionally seen as a statistical programming language, has incorporated OOP features more gradually. The R6 package in R allows for a more classical approach to OOP, supporting encapsulation and inheritance but in a somewhat different manner than Python. The R6 framework allows R developers to create classes with reference semantics, which can be somewhat akin to how Python's classes operate.\n\nHere's how you might define a similar set of microwave classes in R using the R6 package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R6)\nmicrowave_oven_factory <- R6Class(\n    \"MicrowaveOven\",\n    private = list(power_rating_watts = 800),\n    public = list(\n        cook = function(time_seconds) {\n            Sys.sleep(time_seconds)\n            print(\"Your food is cooked!\")\n        }\n    )\n)\n\nfancy_microwave_oven_factory <- R6Class(\n    \"FancyMicrowaveOven\",\n    inherit = microwave_oven_factory,\n    public = list(\n        cook_baked_potato = function() {\n            self$cook(5)\n            print(\"Enjoy your baked potato!\")\n        }\n    )\n)\n\na_fancy_microwave <- fancy_microwave_oven_factory$new()\na_fancy_microwave$cook_baked_potato()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Your food is cooked!\"\n[1] \"Enjoy your baked potato!\"\n```\n\n\n:::\n:::\n\n\nIn the R example, FancyMicrowaveOven is defined with inherit = microwave_oven_factory, which establishes an inheritance relationship with MicrowaveOven. This setup allows the fancy microwave to use the cook method from its parent class while adding a new method cook_baked_potato.\n\n## Differences\n\nA key difference in the OOP implementation between Python and R is the syntax and the explicit use of self and super. In Python, self refers to the instance itself and is used to access class attributes and methods from within. super(), on the other hand, is used to call methods from a superclass in the context of inheritance.\n\nIn R's R6, self serves a similar purpose as in Python, referring to the current object. However, R6 does not have a direct counterpart to Python's super; instead, method overriding involves calling the superclass method directly through super$method_name(). Inheritance in R6 is established through the inherit parameter in the class definition, allowing the new class to access the public methods and properties of the parent class.\n\n## Conclusion\n\nIn summary, while Python's OOP features have been integral to the language from its conception, R has adopted OOP paradigms over time, with packages like R6 introducing class-based programming that includes inheritance. Both languages offer robust capabilities for OOP, facilitating complex and modular program design. In practice, choosing between Python and R for OOP depends on the specific requirements of your project and your personal or team's familiarity with each language.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}